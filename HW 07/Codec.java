/**
 * Name : Hector Herrera
 * PennKey : Hectorh
 * Recitation : 216
 * 
 * Execution: java Codec
 * 
 * This program will encode or decode between a string and its equivalent value
 * in binary using ASCII values. And will encrpyt or decrpyt a message using a 
 * seed and tap position
 */
public class Codec {
    private static int value;          //acts as a variable to hold values
    private static int insertValue;    //acts as a variable to hold values
    
    /**
     * Description: takes in a String and will return an int[] where each 
     * element is a single bit in the ASCII encoding of the String
     * 
     * Input: a string representing the message we want to encode 
     * 
     * Output: an int array representing the ASCII encoding of the string
     */
    public static int[] encode(String str) {
        //checks if str is null
        if (str == null) return null;
        
        else {
            //creates the int[] of an appropriate length 
            int [] arr = new int[7 * str.length()];
            
            //convert the string to it's ASCII value
            for (int i = 0; i < str.length(); i++) {
                value = (int) str.charAt(i);
                if (value > 127) {
                    throw new RuntimeException("ERROR: value is not part of " +  
                                               "ASCII subset of Unicode");
                }
                
                //converts the ASCII value to binary
                for (int j = 0; j < 7; j++) {
                    insertValue = value % 2;
                    value = value / 2;
                    arr[6 + (7 * i) - j] = insertValue; 
                } 
            }
            return arr;
        }
    }
    
    
    /**
     * Description: will accept an array of int representing a message in 
     * ASCII, and will return the decoded String
     * 
     * Input: an int array representing the ASCII encoding of the string
     * 
     * Output: a string representing the message we want to decode
     */
    public static String decode(int[] bits) { 
        //safety checks if bits is null
        if (bits != null) {
            //create an array of appropriate length
            int [] array = new int[bits.length / 7];
           
            String str = "";
            
            //safety checks if bits.length is divisible by 7
            if (bits.length % 7 != 0) {
                throw new RuntimeException("ERROR: bits length is not a " + 
                                           "multiple of 7");
            }
            
            //safety checks if bits contains values other than 1s and 0s
            for (int i = 0; i < bits.length; i++) {
                if (!(bits[i] == 0 || bits[i] == 1)) {
                    throw new RuntimeException("ERROR: bits contains numbers " +  
                                               "other than 0s and 1s"); 
                }
            }
            
            //turn the bits into an int
            for (int z = 0; z < bits.length; z = z + 7) {
                int hold = 0;
                for (int i = 0; i < 7; i++) {
                    
                    //gives the appropriate ASCII representation of the bits 
                    if ((i + z) % 7 == 0) {
                        value = 0;
                        if (bits[z + i] == 1) {
                            hold = (int) Math.pow(2, 6 - (z + i) % 7);
                            
                        }
                    }
                    
                    //gives the appropriate ASCII representation of the bits 
                    if (bits[z + i] == 1 && (i + z) % 7 != 0) {
                        value += (int) Math.pow(2, 6 - (z + i) % 7);
                    }  
                }
                //adds the values to the string to get the message
                str += (char) (value + hold);   
            }
            return str;
        }
        else return null;
    }
       
     /**
     * Description: encrypt messages by xor-ing them with a sequence of 
     * pseudo-random bits generated by the LFSR
     * 
     * Input: an int[] representing the message, a string representing the
     * seed and a tap position to encrypt the message.
     * 
     * Output: void
     */
    public static void encrypt(int[] message, String seed, int tapPosition) {
        //safety checks if seed is null
        if (seed == null) throw new RuntimeException("ERROR: Seed is null");
        //safety checks the tap position 
        if (tapPosition >= seed.length() || tapPosition < 0) {
            throw new RuntimeException("ERROR: tapPosition refers to an " +
                                       "imposible position");
        }
        //safety checks themessage
        if (message == null) return;
        //safety checks the message length
        if (message.length % 7 != 0) {
            throw new RuntimeException("ERROR: message length is not a " + 
                                       "multiple of 7");
        }
        //saftey checks the values in the seed
        for (int i = 0; i < seed.length(); i++) {
            if (!(seed.charAt(i) == '1' || seed.charAt(i) == '0')) {
                throw new RuntimeException("ERROR: seed contains numbers " + 
                                           "other than 0 and 1");
            }
        }
        //saftey checks the values in the message
        for (int i = 0; i < message.length; i++) {
            if (!(message[i] == 1 || message[i] == 0)) {
                throw new RuntimeException("ERROR: message contains numbers " + 
                                           "other than 0 and 1");
            }
        }
        
        //generate the pseudo-random bits
        LFSR lfsr = new LFSR(seed, tapPosition);
        
        //XOR the message and lfsr to encrypt the message
        for (int i = 0; i < message.length; i++) {
            message[i] = message[i] ^ lfsr.nextBit();
        } 
    }
    
    /**
     * Description: decrypt messages by xor-ing them with a sequence of 
     * pseudo-random bits generated by the LFSR
     * 
     * Input: an int[] representing the cipher, a string representing the
     * seed and a tap position to encrypt the message.
     * 
     * Output: void
     */
    public static void decrypt(int[] cipher, String seed, int tapPosition) {
        encrypt(cipher, seed, tapPosition);
    }
    
    public static void main(String[]args) {
        //TEST CODE
        /*int[] arr = encode("C");
        //for (int z = 0; z < arr.length; z++) {
        //System.out.print(arr[z]);
        //}
        
        //String str = decode(arr);
        //System.out.println(str);
        
        encrypt(arr, "01101000010", 8);
        //decrypt*/
    }
}